# -*- coding: utf-8 -*-
"""vinos recomendacionv3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17OdIgnzzx87lqW6VbfTTMOcOzuahNsP1
"""

import zipfile
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
from sklearn.neighbors import NearestNeighbors

import zipfile
import pandas as pd
import json

api_token={"username":"luisfhidalgo",
           "key":"d4e4e6425d85ef204447086541cb5b11"}
!rm -rf /roo/.kaggle. # Elimina de forma recursiva y forzada un directorio y su contenido.Por si existe
!mkdir  /root/.kaggle # Crea Directorio

with open('/root/.kaggle/kaggle.json', 'w') as file:
    json.dump(api_token, file)
!chmod 600 /root/.kaggle/kaggle.json
!kaggle datasets download -d zynicide/wine-reviews
archivo_zip = 'wine-reviews.zip'

# Listar los archivos dentro del ZIP
with zipfile.ZipFile(archivo_zip, 'r') as zip_file:
    archivos = zip_file.namelist()
    print("Archivos en el ZIP:")
    for archivo in archivos:
        print(archivo)
#Cargo los Archivos Dataset a los dataframe que voy a utilizar

archivo_zip = 'wine-reviews.zip'

with zipfile.ZipFile(archivo_zip, 'r') as zip_file:

        with zip_file.open('winemag-data-130k-v2.csv') as winemag_130_csv:  # winemag-data-130k-v2.csv
            winemag_df = pd.read_csv(winemag_130_csv)

duplicados = winemag_df.duplicated().sum()
print("Cantidad de duplicados:",duplicados) # son registros exactamente iguales
winemag_df.drop_duplicates(inplace=True)
# Se elimina columna  'Unnamed: 0',
#winemag_df.drop('Unnamed: 0', axis=1, inplace=True)
winemag_df.isnull().sum()
# Se completan valores nulos en 'designation' y 'region_1'
winemag_df.loc[:, 'designation'] = winemag_df['designation'].fillna('Unknown')
winemag_df.loc[:, 'region_1'] = winemag_df['region_1'].fillna('Unknown')
winemag_df.loc[:, 'region_2'] = winemag_df['region_2'].fillna('Unknown')
winemag_df.loc[:, 'taster_twitter_handle'] = winemag_df['taster_twitter_handle'].fillna('Unknown')
winemag_df = winemag_df.dropna(subset=['taster_name'])
# Imputaci√≥n con la mediana en el campo 'price'
mediana_precio = winemag_df['price'].median()
winemag_df.loc[:, 'price'] = winemag_df['price'].fillna(mediana_precio)
# Se elimina  las 5 filas con valores nulos en la columna 'country'
winemag_df = winemag_df.dropna(subset=['country']).copy()

winemag_df.info()

df = winemag_df.copy()

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

### MODELO BASADO EN CONTENIDO ###
def recomendar_vinos_contenido(vino_id, df=winemag_df): # indice de vino y df

    df["features"] = df["variety"].fillna("") + " " + df["country"].fillna("") + " " + df["description"].fillna("")

# Crea una nueva columna features combinando variedad de uva, pa√≠s y descripci√≥n del vino en un solo texto
# stop_words="english" elimina palabras comunes como "the", "and", "of".
# max_features=3000 limita el n√∫mero de palabras a 3000 para reducir el consumo de memoria.

    vectorizer = TfidfVectorizer(stop_words="english", max_features=3000)  # Reducir a√∫n m√°s caracter√≠sticas
    tfidf_matrix = vectorizer.fit_transform(df["features"])

# Calcula la similitud coseno entre los vinos bas√°ndose en los vectores TF-IDF.
#  Solo usa las primeras 3000 filas para ahorrar memoria.
    cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix[:3000])  # Calcular similitudes solo con una parte
    sim_scores = list(enumerate(cosine_sim[vino_id])) # La similitud del coseno entre ese vino y el vino con vino_id. El √≠ndice de un vino en el DataFrame.
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:11]  # toma los Top 10
    wine_indices = [i[0] for i in sim_scores] # Este c√≥digo toma los √≠ndices de los vinos m√°s similares y los usa para recuperar la informaci√≥n de esos vinos en el DataFrame.
    return df.iloc[wine_indices][["title", "variety", "country"]]

# Ejemplo de recomendaciones
print("Recomendaciones Basadas en Contenido:")
print(recomendar_vinos_contenido(10))

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from surprise import SVD, Dataset, Reader, KNNBasic
from surprise.model_selection import train_test_split
from surprise import accuracy

### MODELO COLABORATIVO ###
def entrenar_modelo_colaborativo(df):
    """
    Entrena un modelo KNN m√°s ligero basado en puntuaciones de usuarios.
    """
    reader = Reader(rating_scale=(df["points"].min(), df["points"].max()))
    data = Dataset.load_from_df(df[["taster_name", "title", "points"]], reader)
    trainset, testset = train_test_split(data, test_size=0.2)

    model = KNNBasic(k=10)  # Reducir n√∫mero de vecinos
    model.fit(trainset)

    predictions = model.test(testset)
    print(f"RMSE: {accuracy.rmse(predictions)}")
    return model

def recomendar_vinos_usuario(usuario, model, df, n=5):
    """
    Recomienda vinos a un usuario basado en puntuaciones previas.
    """
    vinos_unicos = df["title"].unique()
    num_vinos = min(len(vinos_unicos), 50)  # Ajustar cantidad para evitar error
    vinos_no_probados = np.random.choice(vinos_unicos, num_vinos, replace=False)

    predicciones = [model.predict(usuario, vino) for vino in vinos_no_probados]
    predicciones = sorted(predicciones, key=lambda x: x.est, reverse=True)[:n]
    return [pred.iid for pred in predicciones]

# Entrenar modelo colaborativo
modelo_colab = entrenar_modelo_colaborativo(df)

print("\nRecomendaciones Basadas en Colaboraci√≥n:")
print(recomendar_vinos_usuario("John Doe", modelo_colab, df))

""" Recomendar vinos a una persona:

1Ô∏è‚É£ Modelo basado en contenido
Este modelo recomienda vinos seg√∫n sus caracter√≠sticas.

¬øC√≥mo lo hace?

Se fija en cosas como el tipo de uva, el pa√≠s de origen y la descripci√≥n del vino.
Usa una t√©cnica llamada TF-IDF, que convierte palabras en n√∫meros para comparar vinos.
Luego, usa similitud coseno, que es una forma matem√°tica de medir qu√© tan parecidos son dos vinos.
Finalmente, te muestra los 10 vinos m√°s parecidos al que elegiste.


2Ô∏è‚É£ Modelo colaborativo  
Este modelo no se fija en los vinos en s√≠, sino en lo que le gust√≥ a la gente con gustos parecidos a los tuyos.

¬øC√≥mo lo hace?

Toma en cuenta las puntuaciones de diferentes personas.
Usa un modelo llamado KNN (K-Nearest Neighbors), que busca usuarios con gustos similares al tuyo.
Predice qu√© vinos te podr√≠an gustar bas√°ndose en lo que probaron otros con gustos similares.


Hallazgos interesantes (insights) üßê
El modelo basado en contenido funciona bien cuando quieres recomendaciones parecidas a un vino en particular.
El modelo colaborativo es √∫til cuando quieres descubrir vinos nuevos basados en opiniones de otros.
Si tienes poca informaci√≥n de usuarios (pocas puntuaciones), el modelo colaborativo puede fallar porque no hay suficientes datos para comparar.
Si dos vinos tienen descripciones muy diferentes, el modelo basado en contenido no los ver√° como similares, aunque sean buenos.
Si un vino tiene muchas puntuaciones altas, el modelo colaborativo lo recomendar√° m√°s seguido.
Conclusi√≥n:

Si ya tienes un vino favorito y quieres m√°s como ese ‚û° Modelo basado en contenido.
Si quieres descubrir vinos nuevos seg√∫n otros usuarios ‚û° Modelo colaborativo.
üî• Dato curioso: Empresas como Netflix, Amazon y Spotify usan estos mismos m√©todos para hacerte recomendaciones. ¬°Lo que est√°s aprendiendo es s√∫per √∫til en la vida real! üòÉ
"""